
package org.n52.server.ses.service;

import static java.lang.String.valueOf;
import static java.util.UUID.randomUUID;
import static org.n52.shared.serializable.pojos.UserRole.isAdmin;
import static org.n52.shared.session.SessionInfoBuilder.aSessionInfo;

import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import org.n52.shared.serializable.pojos.User;
import org.n52.shared.serializable.pojos.UserRole;
import org.n52.shared.session.SessionInfo;
import org.n52.shared.session.SessionInfoBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ServerSessionStore {

    // TODO extent session store to touch active sessions (expand expiration)

    private static final Logger LOGGER = LoggerFactory.getLogger(ServerSessionStore.class);

    private Map<String, SessionInfo> notLoggedInSessions = new HashMap<String, SessionInfo>();

    private Map<String, SessionInfo> sessionToLoggedInUserName = new HashMap<String, SessionInfo>();

    /**
     * Creates an active session for the given user. If the given (inactive) session object was not generated
     * by this server instance an exception will be thrown.<br>
     * <br/>
     * Once a new session is created and bound to the user the inactive session becomes obsolete and unknown
     * to the server.
     * 
     * @param user
     *        the user to bind a session with.
     * @param inactiveSession
     *        the inactive (not bound to a user) session.
     * @return an active session object for the given user.
     * @throws Exception
     *         if given session was not generated by this server instance.
     */
    public SessionInfo createLoginSessionFor(User user, SessionInfo inactiveSession) throws Exception {
        final SessionInfo sessionInfo = createSessionInfoFor(user, inactiveSession);
        sessionToLoggedInUserName.put(sessionInfo.getSession(), sessionInfo);
        scheduleLoginSessionExpiration(sessionInfo);
        return sessionInfo;
    }

    /**
     * Creates and remembers a session object. Once created the server knows the session and considers it to
     * be a not-logged-in session. A user can be bound to a session object via
     * {@link #createLoginSessionFor(User, SessionInfo)}.
     * 
     * @return a session object which is valid to the given domain.
     */
    public SessionInfo createNotLoggedInSession() {
        SessionInfo notLoggedInSession = aSessionInfo(randomUUID().toString()).build();
        notLoggedInSessions.put(notLoggedInSession.getSession(), notLoggedInSession);
        return notLoggedInSession;
    }

    private SessionInfo createSessionInfoFor(User user, SessionInfo inactiveSession) throws Exception {
        if (isInactiveSessionInfo(inactiveSession)) {
            notLoggedInSessions.remove(inactiveSession);
            SessionInfoBuilder builder = aSessionInfo(randomUUID().toString());
            builder.forUser(user.getUserName());
            builder.withUserId(valueOf(user.getId()));
            builder.withRole(user.getRole().name());
            return builder.build();
        }
        else {
            throw new Exception("Session was not generated by this server.");
        }
    }

    public boolean isInactiveSessionInfo(SessionInfo sessionInfo) {
        return notLoggedInSessions.containsKey(sessionInfo.getSession());
    }

    public void scheduleLoginSessionExpiration(final SessionInfo sessionInfo) {
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                // TODO update expiring date? => cookie has also to be reset on client side
                ServerSessionStore.this.removeSession(sessionInfo);
            }
        }, sessionInfo.getExpiringDate());
    }

    public void removeSession(SessionInfo sessionInfo) {
        sessionToLoggedInUserName.remove(sessionInfo.getSession());
    }

    /**
     * @param sessionInfo
     *        the session info to validate.
     * @throws Exception
     *         if session info is not valid.
     */
    public void validateSessionInfo(SessionInfo sessionInfo) throws Exception {
        if ( !isActiveSessionInfo(sessionInfo)) {
            LOGGER.info("Invalid login session: {}", sessionInfo);
            throw new Exception("Login session is or has become invalid!");
        }
    }

    /**
     * @param sessionInfo
     *        the session info to check for validity.
     * @return <code>true</code> when session info is known and valid, <code>false</code> otherwise.
     */
    public boolean isActiveSessionInfo(SessionInfo sessionInfo) {
        String sessionId = sessionInfo.getSession();
        return sessionToLoggedInUserName.containsKey(sessionId);
    }

    /**
     * Gets the user id of the given session if known by this instance. If session is not known an
     * {@link IllegalArgumentException} is thrown.
     * 
     * @param sessionInfo
     *        the session info.
     * @return the id of the logged in user.
     * @see ServerSessionStore#validateSessionInfo(SessionInfo)
     */
    public String getLoggedInUserId(SessionInfo sessionInfo) {
        return getKnownSession(sessionInfo).getUserId();
    }

    /**
     * Checks if the user of the given session info is of role {@link UserRole#ADMIN}. If session is not known
     * an {@link IllegalArgumentException} is thrown.
     * 
     * @param sessionInfo
     *        the session info to check.
     * @return <code>true</code> if login session is known and user has admin role, <code>false</code> if
     *         session is known but user has not an admin role.
     * @see ServerSessionStore#validateSessionInfo(SessionInfo)
     */
    public boolean isLoggedInAdmin(SessionInfo sessionInfo) {
        return isAdmin(getKnownSession(sessionInfo).getRole());
    }

    /**
     * @param sessionInfo
     *        the session which should be known.
     * @return the known session.
     * @throws IllegalArgumentException
     *         if the session is not known or has become invalid.
     */
    private SessionInfo getKnownSession(SessionInfo sessionInfo) {
        if ( !sessionToLoggedInUserName.containsKey(sessionInfo.getSession())) {
            throw new IllegalArgumentException("Unknown or invalid session: " + sessionInfo);
        }
        return sessionToLoggedInUserName.get(sessionInfo.getSession());
    }

}
